#######################
# This script performs different analysis and statistics on the defined markov model.
# Descostes March 2017
#######################


library("RColorBrewer");
library("NGSprofiling");
library("circlize");
library("ggplot2");
library("IRanges");
library("GenomicFeatures");
library("Rsamtools");
library("GenomicAlignments");
library("edgeR");
library("Rargs");


################
# PARAMETERS
################


#parameters defined from the command line using RIO
paramsDefinition <- list();

#firstly, definition of mandatory parameters that have to be given by the user in the command line

paramsDefinition[["--bedFileModel"]] <- list(variableName="bed_file_model", numeric=F, mandatory=T, description="Path to the bed file (dense) generated by chromHMM.");
paramsDefinition[["--outputFolder"]] <- list(variableName="output_folder", numeric=F, mandatory=T, description="Path to the folder where results will be written.");
paramsDefinition[["--genomeVersion"]] <- list(variableName="genome_version", numeric=F, mandatory=T, description="hg19 and mm10 are currently supported.");
paramsDefinition[["--refseqFile"]] <- list(variableName="refseq_file", numeric=F, mandatory=T, description="Path to the refseq annotations file in gff format.");
paramsDefinition[["--refseqAnnoGtf"]] <- list(variableName="refseq_anno_gtf", numeric=F, mandatory=T, description="Path to the refseq annotations file in gtf format.");
paramsDefinition[["--bamFileRnaseq"]] <- list(variableName="bam_file_rnaseq", numeric=F, mandatory=T, description="Path to the bam file of RNA-seq data corresponding to the experiment.");
paramsDefinition[["--singleEnd"]] <- list(variableName="single_end", numeric=F, mandatory=T, description="Boolean indicating if the RNA-seq was performed in single or paired end.", postConversion=as.logical);
paramsDefinition[["--outputFormat"]] <- list(variableName="output_format", numeric=F, mandatory=T, description="Can be 'ps', 'pdf' or 'png'.");
paramsDefinition[["--colVecOriginal"]] <- list(variableName="col_vec_original", numeric=F, mandatory=T, description="Vector defining the colors of the domains determined by chromHMM.");



#bed_file_model <- "/ifs/home/descon01/analysis/fact_ledgf/hiddenMarkovModel/chromHMM/293TRex/after_factGary/model4_gary-window-80000/learned_states/4-states/293TRex_4_model4_gary_dense.bed";
#
#output_folder <- "/ifs/home/descon01/analysis/fact_ledgf/hiddenMarkovModel/analysis/";
#
#genome_version <- "hg19"; # for mouse use mm10

#tracks_bed_vec <- c("/ifs/home/descon01/data/gary_paper_data/bed_files_from_wigs/293_TRex/WIGfs_Flag-hdgf2_293_native_filtered_unireads_elEst121_AThr7_bin50_Scaled_BGSub-save.bed",
#		"/ifs/home/descon01/data/gary_paper_data/bed_files_from_wigs/293_TRex/WIGfs_Flag-ledgf_293_native_filtered_unireads_elEst131_AThr6_bin50_Scaled_BGSub-save.bed",
#		"/ifs/home/descon01/data/gary_paper_data/bed_files_from_wigs/293_TRex/WIGfs_H3K27me3_filtered_unireads_elEst191_AThr4_bin50_Scaled_BGSub-save.bed",
#		"/ifs/home/descon01/data/gary_paper_data/bed_files_from_wigs/293_TRex/WIGfs_H3K36me2_filtered_unireads_elManual184_AThr4_bin50_Scaled_BGSub-save.bed",
#		"/ifs/home/descon01/data/gary_paper_data/bed_files_from_wigs/293_TRex/WIGfs_H3K36me3_filtered_unireads_elManual173_AThr5_bin50_Scaled_BGSub-save.bed",
#		"/ifs/home/descon01/data/gary_paper_data/bed_files_from_wigs/293_TRex/WIGfs_merge_spt16-1-2_filtered_filtered_unireads_elManual162_AThr4_bin50_Scaled_BGSub-save.bed",
#		"/ifs/home/descon01/data/gary_paper_data/bed_files_from_wigs/293_TRex/WIGfs_RNAPolII_filtered_unireads_elEst171_AThr3_bin50_Scaled_BGSub-save.bed");






#bed_file_model <- "/home/descostes/Documents/analysis/fact_ledgf/hidden_markov_model/chromHMM/293TRex/after_factGary/model4_gary-window-80000/learned_states/4-states/293TRex_4_model4_gary_dense.bed";
#
#output_folder <- "/home/descostes/Documents/analysis/fact_ledgf/hidden_markov_model/analysis/for_paper/";
#
#genome_version <- "hg19"; # for mouse use mm10
#
#refseq_file <- "/home/descostes/Documents/Annotations/human/human/hg19/gff_files/refseq_hg19.gff";
#
#refseq_anno_gtf <- "/home/descostes/Documents/Annotations/human/human/hg19/refseq_hg19.gtf";
#
#bam_file_rnaseq <- "/home/descostes/Documents/analysis/fact_ledgf/bam_file/293TRex_WT_SORTED_PICARD_COOR.bam"; 
#		
#single_end <- TRUE;
#
#output_format <- "ps";
#
#col_vec_original <- c("#7FC97F", "#BEAED4", "#FDC086", "#FFFF99")

#tracks_bed_vec <- c("/home/descostes/Documents/analysis/fact_ledgf/bed_from_wig/WIGfs_Flag-hdgf2_293_native_filtered_unireads_elEst121_AThr7_bin50_Scaled_BGSub-save.bed",
#		"/home/descostes/Documents/analysis/fact_ledgf/bed_from_wig/WIGfs_Flag-ledgf_293_native_filtered_unireads_elEst131_AThr6_bin50_Scaled_BGSub-save.bed",
#		"/home/descostes/Documents/analysis/fact_ledgf/bed_from_wig/WIGfs_H3K27me3_filtered_unireads_elEst191_AThr4_bin50_Scaled_BGSub-save.bed",
#		"/home/descostes/Documents/analysis/fact_ledgf/bed_from_wig/WIGfs_H3K36me2_filtered_unireads_elManual184_AThr4_bin50_Scaled_BGSub-save.bed",
#		"/home/descostes/Documents/analysis/fact_ledgf/bed_from_wig/WIGfs_H3K36me3_filtered_unireads_elManual173_AThr5_bin50_Scaled_BGSub-save.bed",
#		"/home/descostes/Documents/analysis/fact_ledgf/bed_from_wig/WIGfs_merge_spt16-1-2_filtered_filtered_unireads_elManual162_AThr4_bin50_Scaled_BGSub-save.bed",
#		"/home/descostes/Documents/analysis/fact_ledgf/bed_from_wig/WIGfs_RNAPolII_filtered_unireads_elEst171_AThr3_bin50_Scaled_BGSub-save.bed");



################




##############
# MAIN
##############


# Retreives the parameters
getParams(paramsDefinition);


## Checking param

if(length(bed_file_model) != 1 || length(output_folder) != 1)
{
	stop("The bed file of the markov model and the output folder should be unique\n");
}


if(genome_version != "hg19" && genome_version != "mm10")
{
	stop("Check the documentation for using another genome than hg19 and mm10, it should work without changes however\n");
}

checkingOutputFolder(output_folder);



#######
# Part 1: Reading and separating files.
#######

cat("Reading and separating files.\n");

complete_bed <- read.table(bed_file_model, stringsAsFactors=F, skip=1);

#tracks_bed_list <- list();
#for(i in 1:length(tracks_bed_vec)) 
#{
#	cat("bed ", i, "/", length(tracks_bed_vec), "\n");
#	current_fi <- read.table(tracks_bed_vec[i], stringsAsFactor=FALSE);
#	tracks_bed_list[[i]] <- current_fi[-which(current_fi[,5] == 0),];
#	rm(current_fi);
#	gc(verbose=FALSE);
#}

# changing colors in the data frame

col_vec <- factor(complete_bed$V9);
levels(col_vec) <- col_vec_original;
complete_bed$V9 <- as.character(col_vec);


states_list <- split(complete_bed, complete_bed$V4);
col_vec <- col_vec_original;

# Writing the different bed files to the output folder

states_name_vec <- paste("state-", unlist(lapply(states_list, function(x){return(unique(x$V4))})), sep="");

result <- mapply(function(table, expname){
			write.table(table, file=paste(output_folder, expname, ".bed", sep=""), quote=F, sep="\t", row.names=F, col.names=F);
		}, states_list, states_name_vec);



#######
# Part 2: Providing a global genomic repartition with a circular plot.
#######


cat("Plotting circular plot for:\n");

output_folder_circular <- paste(output_folder, "circular_plot/", sep="");
checkingOutputFolder(output_folder_circular);

chromosome_index <- c("NULL", unique(complete_bed$V1));

for(current_chromosome in chromosome_index)
{
	cat("\t", current_chromosome, "\n");
	
	if(output_format == "png")
	{
		png(filename=paste(output_folder_circular, if(current_chromosome == "NULL") "all_chrom_" else current_chromosome,"_circularplot.png",sep=""), width = 1000, height = 1000, bg = "transparent");
	}else if(output_format == "ps"){
		cairo_ps(filename=paste(output_folder_circular, if(current_chromosome == "NULL") "all_chrom_" else current_chromosome,"_circularplot.ps",sep=""), width = 7, height = 7, bg = "transparent");
	}else{
     pdf(file=paste(output_folder_circular, if(current_chromosome == "NULL") "all_chrom_" else current_chromosome,"_circularplot.pdf",sep=""), width=10, height=10)
 }
	par(mar = c(1, 1, 1, 1))
	circos.initializeWithIdeogram(cytoband = read.cytoband(genome_version), 
			species = genome_version, 
			sort.chr = TRUE,
			chromosome.index = if(current_chromosome == "NULL") NULL else current_chromosome, 
			major.by = NULL,
			plotType = c("ideogram", "axis", "labels"));
	
	circos.genomicTrackPlotRegion(states_list, stack = TRUE,
			panel.fun = function(region, value, ...) {
				i = getI(...)
				circos.genomicRect(region, value, ytop = i + 0.4, ybottom = i - 0.4, col = value[[6]], border= value[[6]],...)}, bg.border = NA);
	
	for(i in length(states_list):1) 
	{
		if(current_chromosome != "NULL")
		{
			if(length(which(states_list[[i]][,1] == current_chromosome)) != 0)
			{
				circos.genomicDensity(states_list[[i]], col = unique(states_list[[i]]$V9), track.height = 0.1);
			}
			
		}else{
			circos.genomicDensity(states_list[[i]], col = unique(states_list[[i]]$V9), track.height = 0.1);
		}
	}
	
	circos.clear();
	dev.off();
}



######
# Part3: Plotting statistics on the domains
######

cat("Plotting statistics on the domains\n");

output_folder_domains <- paste(output_folder, "domains_stat/", sep="");
checkingOutputFolder(output_folder_domains);

### Computing a barplot/pie chart of the number of states/domains

nb_states_vec <- unlist(lapply(states_list, nrow));

# Histogram
if(output_format == "png")
{
	png(filename=paste(output_folder_domains, "nb_of_states-hist.png",sep=""), width = 600, height = 600, bg = "transparent")
}else if(output_format == "ps"){
	cairo_ps(filename=paste(output_folder_domains, "nb_of_states-hist.ps",sep=""), width = 7, height = 7, bg = "transparent");
}else{
    pdf(file=paste(output_folder_domains, "nb_of_states-hist.pdf",sep=""), width=10, height=10)
}
barplot(nb_states_vec, beside=TRUE, col= col_vec_original, names.arg= states_name_vec, ylab= "Number of states", las=2);
dev.off();

#Pie chart
if(output_format == "png")
{
	png(filename=paste(output_folder_domains, "nb_of_states-pie.png",sep=""), width = 600, height = 600, bg = "transparent")
}else if(output_format == "ps"){
	cairo_ps(filename=paste(output_folder_domains, "nb_of_states-pie.ps",sep=""), width = 7, height = 7, bg = "transparent");
}else{
    pdf(file=paste(output_folder_domains, "nb_of_states-pie.pdf",sep=""), width=10, height=10)
}
pie(nb_states_vec, main= "Number of domains", labels= paste(states_name_vec, nb_states_vec, sep="-"), col = col_vec_original, border=NA);
dev.off();


### Computing a barplot/pie chart of the genome coverage

genome_coverage_vec <- as.numeric(unlist(lapply(states_list, function(x){length_vec <- x$V3 - x$V2;return(sum(length_vec));})));
if(output_format == "png")
{
	png(filename=paste(output_folder_domains, "genome-coverage.png",sep=""), width = 600, height = 600, bg = "transparent");
}else if(output_format == "ps"){
	cairo_ps(filename=paste(output_folder_domains, "genome-coverage.ps",sep=""), width = 7, height = 7, bg = "transparent");
}else{
    pdf(file=paste(output_folder_domains, "genome-coverage.pdf",sep=""), width=10, height=10)
}
pie(genome_coverage_vec, main= "Genome Coverage", labels= paste(states_name_vec, genome_coverage_vec, sep="-"), col = col_vec_original, border=NA);
dev.off();



#Computing histogram of domain length

domain_length_list <- lapply(states_list, function(x){
			
			length_vec <- x$V3 - x$V2;
			return(length_vec);
		});


max_third_quartile <- max(as.numeric(unlist(lapply(domain_length_list, function(x){return(summary(x)[[5]])}))));


counts_list <- lapply(domain_length_list, function(x, max_quart){
			
			p <- hist(x, breaks= c(seq(from = 1, to = max_quart, by = max_quart/100), max(x)), plot=FALSE);
						
			#Redifining the histogram regarding the third quartile value			
			#p$counts <- c(p$counts[1:(which(p$breaks > max_quart)[1]-1)], sum(p$counts[which(p$breaks > max_quart)[1]:length(p$counts)]));
			p$counts <- p$counts/length(x);
			
			return(p);
			
		}, max_third_quartile);

y_max_vec <- c(0, max(unlist(lapply(counts_list, function(x){return(max(x$counts))}))));


for(i in 1:length(counts_list)) 
{
	counts_list[[i]]$breaks <- counts_list[[i]]$breaks[-length(counts_list[[i]]$breaks)];
	counts_list[[i]]$breaks[which(counts_list[[i]]$counts == 0)] <- "";
	counts_list[[i]]$breaks[length(counts_list[[i]]$breaks)] <- paste(">", counts_list[[i]]$breaks[length(counts_list[[i]]$breaks)], sep="");
	
	if(output_format == "png")
	{
		png(filename=paste(output_folder_domains, states_name_vec[i],"-domainLength.png",sep=""), width = 600, height = 600, bg = "transparent")
	}else if(output_format == "ps"){
		cairo_ps(filename=paste(output_folder_domains, states_name_vec[i],"-domainLength.ps",sep=""), width = 7, height = 7, bg = "transparent");
	}else{
     pdf(file=paste(output_folder_domains, states_name_vec[i],"-domainLength.pdf",sep=""), width=10, height=10)
 }
	barplot(counts_list[[i]]$counts, ylim = y_max_vec, col= col_vec_original[i], xlab="Domain length", ylab="Frequency/number of domains", main="", names.arg = counts_list[[i]]$breaks, las=2);
	dev.off();
}

		
		

######
# Part4: Plotting statistics on the genes covered by the domains
######


cat("Plotting statistics on the genes covered by the domains\n");

output_folder_genes <- paste(output_folder, "genes_stats/", sep="");
checkingOutputFolder(output_folder_genes);


cat("\t Converting refseq annotations to rangedData\n");

current_gff <- read.table(refseq_file, stringsAsFactors=FALSE);
semicolon_feature <- paste(current_gff[,1], current_gff[,4], current_gff[,5], sep=";");
index_duplicated <- which(duplicated(semicolon_feature));
if(length(index_duplicated) != 0)
{
	current_gff <- current_gff[-index_duplicated,];
}
current_gff_rangedData <- gffToRangedData(current_gff);


cat("\t Converting each state coordinates to rangedData\n");

domains_rangedData_list <- lapply(states_list, function(x){return(bedToRangedData(x));});


cat("\t Computing the overlap between each domain and refseq genes\n");

result_overlap_list <- lapply(domains_rangedData_list, function(domains_coor, refseq_coor){return(findOverlaps(domains_coor, refseq_coor));}, current_gff_rangedData); 


cat("\t Plotting the number of genes per domain\n");

# Distribution

nb_genes_per_domain_list <- lapply(result_overlap_list, function(x){return(as.numeric(as.table(x)))});
max_third_quartile <- max(as.numeric(unlist(lapply(nb_genes_per_domain_list, function(x){return(summary(x)[[5]])}))));


counts_list <- lapply(nb_genes_per_domain_list, function(x, max_quart){
			
			p <- hist(x, breaks= c(0:max_quart, max(x)), plot=FALSE);
			
			#Redifining the histogram regarding the third quartile value			
			#p$counts <- c(p$counts[1:(which(p$breaks > max_quart)[1]-1)], sum(p$counts[which(p$breaks > max_quart)[1]:length(p$counts)]));
			p$counts <- p$counts/length(x);
			
			return(p);
			
		}, max_third_quartile);

y_max_vec <- c(0, max(unlist(lapply(counts_list, function(x){return(max(x$counts))}))));


for(i in 1:length(counts_list)) 
{
	counts_list[[i]]$breaks <- counts_list[[i]]$breaks[-length(counts_list[[i]]$breaks)];
	counts_list[[i]]$breaks[which(counts_list[[i]]$counts == 0)] <- "";
	counts_list[[i]]$breaks[length(counts_list[[i]]$breaks)] <- paste(">", counts_list[[i]]$breaks[length(counts_list[[i]]$breaks)], sep="");
	
	if(output_format == "png")
	{
		png(filename=paste(output_folder_genes, states_name_vec[i],"-Nb_genes_per_domains.png",sep=""), width = 600, height = 600, bg = "transparent")
	}else if(output_format == "ps"){
		cairo_ps(filename=paste(output_folder_genes, states_name_vec[i],"-Nb_genes_per_domains.ps",sep=""), width = 7, height = 7, bg = "transparent");
	}else{
     pdf(file=paste(output_folder_genes, states_name_vec[i],"-Nb_genes_per_domains.pdf",sep=""), width=10, height=10)
 }
	barplot(counts_list[[i]]$counts, col= col_vec_original[i], ylim= y_max_vec, xlab="Nb of genes per domain", ylab="Frequency/number of domains", main="", names.arg = counts_list[[i]]$breaks, las=2);
	dev.off();
}

#Pie chart

nb_genes_total_vec <- as.numeric(unlist(lapply(result_overlap_list, function(x){return(length(unique(subjectHits(x))))}))); 
	
if(output_format == "png")
{
	png(filename=paste(output_folder_genes, "NumberGenes_piechart.png",sep=""), width = 600, height = 600, bg = "transparent");
}else if(output_format == "ps"){
	cairo_ps(filename=paste(output_folder_genes, "NumberGenes_piechart.ps",sep=""), width = 7, height = 7, bg = "transparent");
}else{
    pdf(file=paste(output_folder_genes, "NumberGenes_piechart.pdf",sep=""), width=10, height=10)
}
pie(nb_genes_total_vec, main= "All genes", labels= paste(states_name_vec, nb_genes_total_vec, sep="-"), col = col_vec_original, border=NA);
dev.off();


cat("\t Plotting the distribution of gene lengths for each state\n");


gene_length_per_state_list <- lapply(result_overlap_list, function(x, refseq_data){
			
			refseq_index <- unique(subjectHits(x));
			length_vec <- end(refseq_data[refseq_index,]) - start(refseq_data[refseq_index,]);
			return(length_vec);
			
		}, current_gff_rangedData);

max_third_quartile <- max(as.numeric(unlist(lapply(gene_length_per_state_list, function(x){return(summary(x)[[5]])}))));
min_gene_length <- min(as.numeric(unlist(lapply(gene_length_per_state_list, function(x){return(summary(x)[[1]])}))));


counts_list <- lapply(gene_length_per_state_list, function(x, max_quart, min_length){
			
			p <- hist(x, breaks= c(seq(from = min_length, to = max_quart, by = max_quart/100), max(x)), plot=FALSE);
			
			#Redifining the histogram regarding the third quartile value			
			#p$counts <- c(p$counts[1:(which(p$breaks > max_quart)[1]-1)], sum(p$counts[which(p$breaks > max_quart)[1]:length(p$counts)]));
			p$counts <- p$counts/length(x);
			
			return(p);
			
		}, max_third_quartile, min_gene_length);

y_max_vec <- c(0, max(unlist(lapply(counts_list, function(x){return(max(x$counts))}))));

for(i in 1:length(counts_list)) 
{
	counts_list[[i]]$breaks <- counts_list[[i]]$breaks[-length(counts_list[[i]]$breaks)];
	tmp_seq <- 1:length(counts_list[[i]]$breaks);
	last_element <- counts_list[[i]]$breaks[length(counts_list[[i]]$breaks)];
	counts_list[[i]]$breaks[tmp_seq[-seq(from=1, to=length(counts_list[[i]]$breaks), by=5)]] <- "";
	counts_list[[i]]$breaks[length(counts_list[[i]]$breaks)] <- paste(">", last_element, sep="");
	
	if(output_format == "png")
	{
		png(filename=paste(output_folder_genes, states_name_vec[i],"-geneLength.png",sep=""), width = 600, height = 600, bg = "transparent")
	}else if(output_format == "ps"){
		cairo_ps(filename=paste(output_folder_genes, states_name_vec[i],"-geneLength.ps",sep=""), width = 7, height = 7, bg = "transparent");
	}else{
     pdf(file=paste(output_folder_genes, states_name_vec[i],"-geneLength.pdf",sep=""), width=10, height=10)
 }
	barplot(counts_list[[i]]$counts, ylim= y_max_vec, col= col_vec_original[i], xlab="Gene length", ylab="Frequency/number of genes", main="", names.arg = counts_list[[i]]$breaks, las=2);
	dev.off();
}





######
# Part5: Plotting expression of the genes covered by the domains
######


cat("Plotting expression of the genes covered by the domains\n");


gff_refseq_per_state_list <- lapply(result_overlap_list, function(x, refseq_data){
			
			refseq_index <- unique(subjectHits(x));
			refseq_data <- refseq_data[refseq_index,];
			return(data.frame(space(refseq_data), start(refseq_data), end(refseq_data)));
			
		}, current_gff_rangedData);

# Retrieving refseq annotations

cat("\t Retrieving refseq annotations\n");

gff_refseq_per_state_list <- lapply(gff_refseq_per_state_list, function(x, refseq_complete){
			
			index_vec <- apply(x, MARGIN = 1, function(matrix_row, refseq_complete){
						
						index <- which(refseq_complete$V1 == as.character(matrix_row[[1]]) & refseq_complete$V4 == as.numeric(matrix_row[[2]]) & refseq_complete$V5 == as.numeric(matrix_row[[3]]));
						
						if(length(index) == 0)
						{
							stop("\n The annotation ", matrix_row, " was not found\n");
						}
						
						if(length(index) > 1)
						{
							stop("\n Several annotations were found: ", matrix_row, "\n");
						}
						
						return(index);
					}, refseq_complete)
			
			return(refseq_complete[index_vec,]);
			
		}, current_gff);


# Writing gff files of genes per states

for(i in 1:length(gff_refseq_per_state_list)) 
{
	write.table(gff_refseq_per_state_list[[i]], file=paste(output_folder_genes, states_name_vec[i], ".gff", sep=""), sep="\t", quote=F, row.names=F, col.names=F);
}

#Computing the count table for rna-seq

cat("\t Computing the count table for rna-seq\n");

bamfiles <- BamFileList(bam_file_rnaseq);
txdb <- makeTxDbFromGFF(refseq_anno_gtf, format="gtf");
ebg <- exonsBy(txdb, by="gene");
se <- summarizeOverlaps(features=ebg, reads=bamfiles,
		mode="Union",
		singleEnd=single_end,
		ignore.strand= TRUE,
		fragments= if(single_end) FALSE else TRUE);

matrix_count <- assay(se);
row_name_vec <- rownames(matrix_count);


count_matrix_eachState_list <- lapply(gff_refseq_per_state_list, function(gff_table, matrix_counts, name_vec){
			
			index <- match(gff_table$V3, name_vec);
			
			if(length(which(is.na(index))) != 0){
				
				cat("\n Not found: ", gff_table$V3[which(is.na(index))], "\n");
				index <- index[-which(is.na(index))];
			} 
			
			return(as.matrix(matrix_counts[index,]));
			
		}, matrix_count, row_name_vec)

# Normalization by TPM

count_matrix_eachState_list_tpm_log <- lapply(count_matrix_eachState_list, function(x){return(cpm(x, log=TRUE))});

cat("\t Plotting the distribution for each state\n");
	
		
hist_list <- lapply(count_matrix_eachState_list_tpm_log, function(x){
					
					p <- hist(x, breaks=100, plot=FALSE);
					p$counts <- p$counts/length(x);
					return(p);
				});

y_max_vec <- c(0, max(unlist(lapply(hist_list, function(x){return(max(x$counts))}))));


for(i in 1:length(hist_list)) 
{
	if(output_format == "png")
	{
		png(filename=paste(output_folder_genes, states_name_vec[i],"-expression.png",sep=""), width = 600, height = 600, bg = "transparent");
	}else if(output_format == "ps"){
		cairo_ps(filename=paste(output_folder_genes, states_name_vec[i],"-expression.ps",sep=""), width = 7, height = 7, bg = "transparent");
	}else{
     pdf(file=paste(output_folder_genes, states_name_vec[i],"-expression.pdf",sep=""), width=10, height=10)
 }
	plot(hist_list[[i]], col= col_vec_original[i], ylim=y_max_vec, xlab="log2(TPM(count))", ylab="Frequency/number of genes", main= "");
	dev.off();
}
